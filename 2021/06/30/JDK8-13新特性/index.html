<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JDK8~13新特性"><meta name="keywords" content="JDK8~13新特性"><meta name="author" content="Kaluna"><meta name="copyright" content="Kaluna"><title>JDK8~13新特性 | 嘿，走钢索的人</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="嘿，走钢索的人" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8新特性之接⼝和⽇期处理"><span class="toc-number">1.</span> <span class="toc-text">JDK8新特性之接⼝和⽇期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之default关键字"><span class="toc-number">1.1.</span> <span class="toc-text">JDK8之default关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk1-8之新增Base64加解密API"><span class="toc-number">1.2.</span> <span class="toc-text">jdk1.8之新增Base64加解密API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之时间⽇期处理类"><span class="toc-number">1.3.</span> <span class="toc-text">JDK8之时间⽇期处理类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之Optional类"><span class="toc-number">1.4.</span> <span class="toc-text">JDK8之Optional类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8-Lambda表达式"><span class="toc-number">2.</span> <span class="toc-text">JDK8 Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之-lambda表达式"><span class="toc-number">2.1.</span> <span class="toc-text">JDK8之 lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之⾃定义函数式编程实战"><span class="toc-number">2.2.</span> <span class="toc-text">JDK8之⾃定义函数式编程实战</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8-函数式编程"><span class="toc-number">3.</span> <span class="toc-text">JDK8 函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之函数式编程-Function"><span class="toc-number">3.1.</span> <span class="toc-text">JDK8之函数式编程 Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之函数式编程-BiFunction"><span class="toc-number">3.2.</span> <span class="toc-text">JDK8之函数式编程 BiFunction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之函数式编程-Consumer"><span class="toc-number">3.3.</span> <span class="toc-text">JDK8之函数式编程 Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之函数式编程-Supplier"><span class="toc-number">3.4.</span> <span class="toc-text">JDK8之函数式编程 Supplier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之函数式编程-Predicate"><span class="toc-number">3.5.</span> <span class="toc-text">JDK8之函数式编程 Predicate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之⽅法与构造函数引⽤"><span class="toc-number">3.6.</span> <span class="toc-text">JDK8之⽅法与构造函数引⽤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8-集合框架"><span class="toc-number">4.</span> <span class="toc-text">JDK8 集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之流Stream实战"><span class="toc-number">4.1.</span> <span class="toc-text">JDK8之流Stream实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之流操作map和filter函数"><span class="toc-number">4.2.</span> <span class="toc-text">JDK8之流操作map和filter函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之流操作limit和sorted函数"><span class="toc-number">4.3.</span> <span class="toc-text">JDK8之流操作limit和sorted函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之流操作allMatch和anyMatch函数"><span class="toc-number">4.4.</span> <span class="toc-text">JDK8之流操作allMatch和anyMatch函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之流操作max和min函数"><span class="toc-number">4.5.</span> <span class="toc-text">JDK8之流操作max和min函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8-集合框架进阶"><span class="toc-number">5.</span> <span class="toc-text">JDK8 集合框架进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之并⾏流parallelStream"><span class="toc-number">5.1.</span> <span class="toc-text">JDK8之并⾏流parallelStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之reduce操作"><span class="toc-number">5.2.</span> <span class="toc-text">JDK8之reduce操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之集合的foreach"><span class="toc-number">5.3.</span> <span class="toc-text">JDK8之集合的foreach</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8-收集器和集合统计"><span class="toc-number">6.</span> <span class="toc-text">JDK8 收集器和集合统计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之collector收集器"><span class="toc-number">6.1.</span> <span class="toc-text">JDK8之collector收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之joining函数"><span class="toc-number">6.2.</span> <span class="toc-text">JDK8之joining函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之收集器-partitioningBy分组"><span class="toc-number">6.3.</span> <span class="toc-text">JDK8之收集器 partitioningBy分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之收集器-group-by分组"><span class="toc-number">6.4.</span> <span class="toc-text">JDK8之收集器 group by分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之收集器-group-by进阶"><span class="toc-number">6.5.</span> <span class="toc-text">JDK8之收集器 group by进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8之summarizing集合统计"><span class="toc-number">6.6.</span> <span class="toc-text">JDK8之summarizing集合统计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8-Collection和Lambda实战"><span class="toc-number">7.</span> <span class="toc-text">JDK8 Collection和Lambda实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection和Lambda电商数据处理实战需求说明"><span class="toc-number">7.1.</span> <span class="toc-text">Collection和Lambda电商数据处理实战需求说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理电商订单数据的答案"><span class="toc-number">7.2.</span> <span class="toc-text">处理电商订单数据的答案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK8-新的内存空间和异常处理"><span class="toc-number">8.</span> <span class="toc-text">JDK8 新的内存空间和异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8新特性之新内存空间Matespace"><span class="toc-number">8.1.</span> <span class="toc-text">JDK8新特性之新内存空间Matespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK7新特性之try-with-resources"><span class="toc-number">8.2.</span> <span class="toc-text">JDK7新特性之try-with-resources</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK9常⻅特性"><span class="toc-number">9.</span> <span class="toc-text">JDK9常⻅特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk9新增测试⼯具jshell"><span class="toc-number">9.1.</span> <span class="toc-text">jdk9新增测试⼯具jshell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接⼝⽅法进阶之JDK9私有⽅法"><span class="toc-number">9.2.</span> <span class="toc-text">接⼝⽅法进阶之JDK9私有⽅法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK9新特性之增强try-with-resource"><span class="toc-number">9.3.</span> <span class="toc-text">JDK9新特性之增强try-with-resource</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK9的Stream和集合API"><span class="toc-number">10.</span> <span class="toc-text">JDK9的Stream和集合API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK9之快速创建只读集合"><span class="toc-number">10.1.</span> <span class="toc-text">JDK9之快速创建只读集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK9之新增Stream-API"><span class="toc-number">10.2.</span> <span class="toc-text">JDK9之新增Stream API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK10和JDK11常⻅特性"><span class="toc-number">11.</span> <span class="toc-text">JDK10和JDK11常⻅特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK10之局部变量类型推断var"><span class="toc-number">11.1.</span> <span class="toc-text">JDK10之局部变量类型推断var</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK11之新增HttpClient客户端快速⼊⻔"><span class="toc-number">11.2.</span> <span class="toc-text">JDK11之新增HttpClient客户端快速⼊⻔</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK11之标准HttpClient提交Post和异步请求"><span class="toc-number">11.3.</span> <span class="toc-text">JDK11之标准HttpClient提交Post和异步请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK11之标准HttpClient提交Http2请求"><span class="toc-number">11.4.</span> <span class="toc-text">JDK11之标准HttpClient提交Http2请求</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK12和JDK13"><span class="toc-number">12.</span> <span class="toc-text">JDK12和JDK13</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK⼀些基础知识科普"><span class="toc-number">12.1.</span> <span class="toc-text">JDK⼀些基础知识科普</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK13新特性之多⾏⽂本块"><span class="toc-number">12.2.</span> <span class="toc-text">JDK13新特性之多⾏⽂本块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK13新特性之增强switch表达式"><span class="toc-number">12.3.</span> <span class="toc-text">JDK13新特性之增强switch表达式</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Kaluna</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/lxy1866" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">24</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">15</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210521080208.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">嘿，走钢索的人</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a><a class="site-page" href="/tags/">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">JDK8~13新特性</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JDK/">JDK</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/06/30/JDK8-13%E6%96%B0%E7%89%B9%E6%80%A7/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/06/30/JDK8-13新特性/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="JDK8新特性之接⼝和⽇期处理"><a href="#JDK8新特性之接⼝和⽇期处理" class="headerlink" title="JDK8新特性之接⼝和⽇期处理"></a>JDK8新特性之接⼝和⽇期处理</h1><h2 id="JDK8之default关键字"><a href="#JDK8之default关键字" class="headerlink" title="JDK8之default关键字"></a>JDK8之default关键字</h2><p>在jdk1.8以前接⼝⾥⾯是只能有抽象⽅法，不能有任何⽅法的实现的，jdk1.8⾥⾯打破了这个规定，引⼊了新的关键字default，使⽤default修饰⽅法，可以在接⼝⾥⾯ 定义具体的⽅法实</p>
<ul>
<li>默认⽅法： 接⼝⾥⾯定义⼀个默认⽅法，这个接⼝的实现类实现了这个接⼝之后，这个 default修饰的⽅法就可以直接调⽤，即接⼝⽅法的默认实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">"使⽤氧⽓呼吸"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态⽅法：接⼝名.静态⽅法来访问接⼝中的静态⽅法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"> 	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">"使⽤氧⽓呼吸"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"这是静态⽅法"</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jdk1-8之新增Base64加解密API"><a href="#jdk1-8之新增Base64加解密API" class="headerlink" title="jdk1.8之新增Base64加解密API"></a>jdk1.8之新增Base64加解密API</h2><p>什么是Base64编码？</p>
<p>Base64是⽹络上最常⻅的⽤于传输8Bit字节码的编码⽅式之⼀，Base64就是⼀种基于64个可打印字符来表示⼆进制数据的⽅法 基于64个字符A-Z,a-z，0-9，+，/的编码⽅式， 是⼀种能将任意⼆进制数据⽤64种字元组合成字符串的⽅法，⽽这个⼆进制数据和字符串资料之间是可以互相转换的，在实际应⽤上，Base64除了能将⼆进制数据可视化之外，也常⽤来表示字串加密过后的内容</p>
<p><strong>早期java要使⽤Base64怎么做？</strong></p>
<ul>
<li>使⽤JDK⾥sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">String text = <span class="string">"⼩滴课堂"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line">String encodedText = encoder.encode(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decodeBuffer(encodedText), <span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure>

<p>缺点：编码和解码的效率⽐较差，公开信息说以后的版本会取消这个⽅法</p>
<ul>
<li>Apache Commons Codec有提供Base64的编码与解码 缺点：是需要引⽤Apache Commons Codec</li>
</ul>
<p><strong>jdk1.8之后怎么玩？</strong>(⾸选推荐) </p>
<ul>
<li>Jdk1.8的java.util包中，新增了Base64的类 </li>
<li>好处：不⽤引包，编解码销量远⼤于 sun.misc 和 Apache Commons Codec</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line">Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line">String text = <span class="string">"⼩滴课堂"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] textByte = text.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line">String encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(decoder.decode(encodedText), <span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之时间⽇期处理类"><a href="#JDK8之时间⽇期处理类" class="headerlink" title="JDK8之时间⽇期处理类"></a>JDK8之时间⽇期处理类</h2><p>时间处理再熟悉不过，SimpleDateFormat，Calendar等类。旧版缺点： java.util.Date 是⾮线程安全的，API设计⽐较差，⽇期/时间对象⽐较，加减麻烦 </p>
<p>Java 8通过发布新的Date-Time API (JSR 310)来进⼀步加强对⽇期与时间的处理 新增了很多常⻅的api，如⽇期/时间的⽐较，加减，格式化等，包所在位置：<strong>java.time</strong> </p>
<p><strong>核⼼类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate：不包含具体时间的⽇期。</span><br><span class="line">LocalTime：不含⽇期的时间。</span><br><span class="line">LocalDateTime：包含了⽇期及时间。</span><br></pre></td></tr></table></figure>

<ul>
<li>LocalDate 常⽤API</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"今天⽇期："</span> + today);</span><br><span class="line"><span class="comment">//获取年，⽉，⽇，周⼏</span></span><br><span class="line">System.out.println(<span class="string">"现在是哪年:"</span>+today.getYear());</span><br><span class="line">System.out.println(<span class="string">"现在是哪⽉:"</span>+today.getMonth());</span><br><span class="line">System.out.println(<span class="string">"现在是哪⽉(数字):"</span>+today.getMonthValue());</span><br><span class="line">System.out.println(<span class="string">"现在是⼏号:"</span>+today.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">"现在是周⼏:"</span>+today.getDayOfWeek());</span><br><span class="line"><span class="comment">//加减年份, 加后返回的对象才是修改后的， 旧的依旧是旧的</span></span><br><span class="line">LocalDate changeDate = today.plusYears(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"加后是哪年:"</span>+changeDate.getYear());</span><br><span class="line">System.out.println(<span class="string">"旧的是哪年:"</span>+today.getYear());</span><br><span class="line"><span class="comment">//⽇期⽐较</span></span><br><span class="line">System.out.println(<span class="string">"isAfter: "</span>+changeDate.isAfter(today));</span><br><span class="line"><span class="comment">//getYear() int 获取当前⽇期的年份</span></span><br><span class="line"><span class="comment">//getMonth() Month 获取当前⽇期的⽉份对象</span></span><br><span class="line"><span class="comment">//getMonthValue() int 获取当前⽇期是第⼏⽉</span></span><br><span class="line"><span class="comment">//getDayOfWeek() DayOfWeek 表示该对象表示的⽇期是星期⼏</span></span><br><span class="line"><span class="comment">//getDayOfMonth() int 表示该对象表示的⽇期是这个⽉第⼏天</span></span><br><span class="line"><span class="comment">//getDayOfYear() int 表示该对象表示的⽇期是今年第⼏天</span></span><br><span class="line"><span class="comment">//withYear(int year) LocalDate 修改当前对象的年份</span></span><br><span class="line"><span class="comment">//withMonth(int month) LocalDate 修改当前对象的⽉份</span></span><br><span class="line"><span class="comment">//withDayOfMonth(int dayOfMonth) LocalDate 修改当前对象在当⽉的⽇期</span></span><br><span class="line"><span class="comment">//plusYears(long yearsToAdd) LocalDate 当前对象增加指定的年份数</span></span><br><span class="line"><span class="comment">//plusMonths(long monthsToAdd) LocalDate 当前对象增加指定的⽉份数</span></span><br><span class="line"><span class="comment">//plusWeeks(long weeksToAdd) LocalDate 当前对象增加指定的周数</span></span><br><span class="line"><span class="comment">//plusDays(long daysToAdd) LocalDate 当前对象增加指定的天数</span></span><br><span class="line"><span class="comment">//minusYears(long yearsToSubtract) LocalDate 当前对象减去指定的年数</span></span><br><span class="line"><span class="comment">//minusMonths(long monthsToSubtract) LocalDate 当前对象减去注定的⽉数</span></span><br><span class="line"><span class="comment">//minusWeeks(long weeksToSubtract) LocalDate 当前对象减去指定的周数</span></span><br><span class="line"><span class="comment">//minusDays(long daysToSubtract) LocalDate 当前对象减去指定的天数</span></span><br><span class="line"><span class="comment">//compareTo(ChronoLocalDate other) int ⽐较当前对象和other对象在时间上的⼤⼩，返回值如果为正，则当前对象时间较晚，</span></span><br><span class="line"><span class="comment">//isBefore(ChronoLocalDate other) boolean ⽐较当前对象⽇期是否在other对象⽇期之前</span></span><br><span class="line"><span class="comment">//isAfter(ChronoLocalDate other) boolean ⽐较当前对象⽇期是否在other对象⽇期之后</span></span><br><span class="line"><span class="comment">//isEqual(ChronoLocalDate other) boolean ⽐较两个⽇期对象是否相等</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LocalTime 常⽤API </li>
<li>LocalDateTime 常⽤API</li>
</ul>
<p><strong>⽇期时间格式化</strong> </p>
<ul>
<li>JDK8之前：SimpleDateFormat来进⾏格式化，但SimpleDateFormat并不是线程安全的</li>
<li>JDK8之后：引⼊线程安全的DateTimeFormatter</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String ldtStr = dtf.format(ldt);</span><br><span class="line">System.out.println(ldtStr);</span><br></pre></td></tr></table></figure>

<p><strong>获取指定的⽇期时间对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.of(<span class="number">2020</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(ldt);</span><br></pre></td></tr></table></figure>

<p><strong>计算⽇期时间差 java.time.Duration</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">System.out.println(today);</span><br><span class="line">LocalDateTime changeDate = LocalDateTime.of(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">40</span>,<span class="number">30</span>);</span><br><span class="line">System.out.println(changeDate);</span><br><span class="line">Duration duration = Duration.between( today,changeDate);<span class="comment">//第⼆个参数减第⼀个参数</span></span><br><span class="line">System.out.println(duration.toDays());<span class="comment">//两个时间差的天数</span></span><br><span class="line">System.out.println(duration.toHours());<span class="comment">//两个时间差的⼩时数</span></span><br><span class="line">System.out.println(duration.toMinutes());<span class="comment">//两个时间差的分钟数</span></span><br><span class="line">System.out.println(duration.toMillis());<span class="comment">//两个时间差的毫秒数</span></span><br><span class="line">System.out.println(duration.toNanos());<span class="comment">//两个时间差的纳秒数</span></span><br></pre></td></tr></table></figure>

<h2 id="JDK8之Optional类"><a href="#JDK8之Optional类" class="headerlink" title="JDK8之Optional类"></a>JDK8之Optional类</h2><p><strong>Optional 类有啥⽤?</strong></p>
<ul>
<li>主要解决的问题是空指针异常（NullPointerException） </li>
<li>怎么解决？ 本质是⼀个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空 </li>
</ul>
<p><strong>创建Optional类</strong> </p>
<p>of() </p>
<ul>
<li>null 值作为参数传递进去则会抛异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt = Optional.of(user);</span><br></pre></td></tr></table></figure>

<p>ofNullable()</p>
<ul>
<li>如果对象即可能是 null 也可能是⾮ null，应该使⽤ ofNullable() ⽅法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt = Optional.ofNullable(user);</span><br></pre></td></tr></table></figure>

<p><strong>访问 Optional 对象的值</strong></p>
<p>get() ⽅法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; opt = Optional.ofNullable(student);</span><br><span class="line">Student s = opt.get();</span><br></pre></td></tr></table></figure>

<p>如果值存在则isPresent()⽅法会返回true，调⽤get()⽅法会返回该对象，⼀般使⽤get之前需要先验证是否有值，不然还会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">null</span>;</span><br><span class="line">    test(student);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">    Optional&lt;Student&gt; opt = Optional.ofNullable(student);</span><br><span class="line">    System.out.println(opt.isPresent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>兜底 orElse⽅法 </p>
<ul>
<li>orElse()如果有值则返回该值，否则返回传递给它的参数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student student1 = <span class="keyword">null</span>;</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="number">2</span>);</span><br><span class="line">Student result = Optional.ofNullable(student1).orElse(student2);</span><br><span class="line">System.out.println(result.getAge());</span><br><span class="line"></span><br><span class="line">Student student = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> result = Optional.ofNullable(student).map(obj-&gt;obj.getAge()).orElse(<span class="number">4</span>);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<h1 id="JDK8-Lambda表达式"><a href="#JDK8-Lambda表达式" class="headerlink" title="JDK8 Lambda表达式"></a>JDK8 Lambda表达式</h1><h2 id="JDK8之-lambda表达式"><a href="#JDK8之-lambda表达式" class="headerlink" title="JDK8之 lambda表达式"></a>JDK8之 lambda表达式</h2><p><strong>什么是函数式编程和什么是lambda表达式</strong></p>
<p>在JDK8之前，Java是不⽀持函数式编程的，所谓的函数编程，即可理解是将⼀个函数（也称为“⾏为”）作为⼀个参数进⾏传递， ⾯向对象编程是对数据的抽象（各种各样的POJO类），⽽函数式编程则是对⾏为的抽象（将⾏为作为⼀个参数进⾏传递）</p>
<p><strong>java创建线程再熟悉不过了</strong></p>
<ul>
<li><p>jdk8之前创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"⼩滴课堂学习Java架构教程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>jdk8之后Lambda表达式则只需要使⽤⼀句话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"⼩滴课堂学习Java架构教程"</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>集合容器⾥⾯的字符串排序</strong> </p>
<ul>
<li><p>使⽤前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =Arrays.asList(<span class="string">"aaa"</span>,<span class="string">"ggg"</span>,<span class="string">"ffff"</span>,<span class="string">"ccc"</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使⽤后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =Arrays.asList(<span class="string">"aaa"</span>,<span class="string">"ggg"</span>,<span class="string">"ffff"</span>,<span class="string">"ccc"</span>);</span><br><span class="line">Collections.sort(list, (a,b)-&gt;b.compareTo(a));</span><br><span class="line"><span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>lambda表达式</strong> 使⽤场景(前提)：⼀个接⼝中只包含⼀个⽅法，则可以使⽤Lambda表达式，这样 的接⼝称之为“函数接⼝” 语法： (params) -&gt; expression</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第⼀部分为括号内⽤逗号分隔的形式参数，参数是函数式接⼝⾥⾯⽅法的参数；第⼆部分为⼀个箭</span><br><span class="line">头符号：-&gt;；第三部分为⽅法体，可以是表达式和代码块</span><br><span class="line"></span><br><span class="line">参数列表 ：</span><br><span class="line"> 括号中参数列表的数据类型可以省略不写</span><br><span class="line"> 括号中的参数只有⼀个，那么参数类型和()都可以省略不写</span><br><span class="line">⽅法体：</span><br><span class="line"> 如果&#123;&#125;中的代码只有⼀⾏，⽆论有返回值，可以省略&#123;&#125;，return，分号，要⼀起省略，其他如果需要再加上</span><br></pre></td></tr></table></figure>

<p>好处： <strong>Lambda 表达式的实现⽅式在本质是以匿名内部类的⽅式进⾏实现</strong>，重构现有臃肿代码，更⾼的开发效率，尤其是集合Collection操作的时候，后续会讲到</p>
<h2 id="JDK8之⾃定义函数式编程实战"><a href="#JDK8之⾃定义函数式编程实战" class="headerlink" title="JDK8之⾃定义函数式编程实战"></a>JDK8之⾃定义函数式编程实战</h2><p><strong>⾃定义lambda接⼝流程</strong> </p>
<ol>
<li>定义⼀个函数式接⼝ 需要标注此接⼝ @FunctionalInterface，否则万⼀团队成员在接⼝上加了其他⽅法则容易出故障</li>
<li>编写⼀个⽅法，输⼊需要操做的数据和接⼝ </li>
<li>在调⽤⽅法时传⼊数据 和 lambda 表达式，⽤来操作数据</li>
</ol>
<p><strong>需求，定义⼀个可以使⽤加减乘除的接⼝ 以前需要定义4个⽅法</strong></p>
<p>使⽤Lambda表达式后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义⼀个函数式接⼝ 需要标注此接⼝ @FunctionalInterface</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OperFunction</span>&lt;<span class="title">R</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">(T t1, T t2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (Integer x, Integer y) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">//在调⽤⽅法时传⼊数据 和 lambda 表达式，⽤来操作数据</span></span><br><span class="line">    System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (x, y) -&gt; x + y));</span><br><span class="line">    System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (x, y) -&gt; x - y));</span><br><span class="line">    System.out.println(operator(<span class="number">20</span>, <span class="number">5</span>, (x, y) -&gt; x / y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写⼀个⽅法，输⼊需要操做的数据和接⼝ </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">operator</span><span class="params">(Integer x, Integer y, OperFunction&lt;Integer, Integer&gt; of)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> of.operator(x, y);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDK8-函数式编程"><a href="#JDK8-函数式编程" class="headerlink" title="JDK8 函数式编程"></a>JDK8 函数式编程</h1><h2 id="JDK8之函数式编程-Function"><a href="#JDK8之函数式编程-Function" class="headerlink" title="JDK8之函数式编程 Function"></a>JDK8之函数式编程 Function</h2><p>Lambda表达式必须先定义接⼝，创建相关⽅法之后才可使⽤，这样做⼗分不便，其实java8已经 内置了许多接⼝, 例如下⾯四个功能型接⼝，所以⼀般很少会由⽤户去定义新的函数式接⼝</p>
<p>Java8的最⼤特性就是函数式接⼝，所有标注了@FunctionalInterface注解的接⼝都是函数式接⼝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Java8 内置的四⼤核⼼函数式接⼝</span><br><span class="line">Consumer&lt;T&gt; : 消费型接⼝：有⼊参，⽆返回值</span><br><span class="line"> void accept(T t);</span><br><span class="line"> </span><br><span class="line">Supplier&lt;T&gt; : 供给型接⼝：⽆⼊参，有返回值</span><br><span class="line"> T get();</span><br><span class="line"> </span><br><span class="line">Function&lt;T, R&gt; : 函数型接⼝：有⼊参，有返回值</span><br><span class="line"> R apply(T t);</span><br><span class="line"> </span><br><span class="line">Predicate&lt;T&gt; : 断⾔型接⼝：有⼊参，有返回值，返回值类型确定是boolean</span><br><span class="line"> boolean test(T t);</span><br></pre></td></tr></table></figure>

<p><strong>Function接口</strong></p>
<ol>
<li>传⼊⼀个值经过函数的计算返回另⼀个值 </li>
<li>作⽤：将转换逻辑提取出来，解耦合</li>
<li>T：⼊参类型，R：出参类型 </li>
<li>调⽤⽅法：R apply(T t)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@param &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment">//@param &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>不要看过于复杂，就是⼀个接⼝,下⾯是⾃定义实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionObj</span> <span class="keyword">implements</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o+<span class="string">"经过apply处理拼接上了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常规使⽤</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出⼊参的10倍</span></span><br><span class="line"><span class="comment">//其实就是看成实现类实现了接口的方法</span></span><br><span class="line">Function&lt;Integer, Integer&gt; func = p -&gt; p * <span class="number">100</span>;</span><br><span class="line">func.apply(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之函数式编程-BiFunction"><a href="#JDK8之函数式编程-BiFunction" class="headerlink" title="JDK8之函数式编程 BiFunction"></a>JDK8之函数式编程 BiFunction</h2><p><strong>BiFunction</strong> </p>
<p>Function只能接收⼀个参数，如果要传递两个参数,则⽤ BiFunction</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求：两个数的四则运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(operator(<span class="number">10</span>,<span class="number">21</span>,(a,b)-&gt;a+b));</span><br><span class="line">    System.out.println(operator(<span class="number">10</span>,<span class="number">2</span>,(a,b)-&gt;a-b));</span><br><span class="line">    System.out.println(operator(<span class="number">8</span>,<span class="number">4</span>,(a,b)-&gt;a*b));</span><br><span class="line">    System.out.println(operator(<span class="number">10</span>,<span class="number">2</span>,(a,b)-&gt;a/b));</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">operator</span><span class="params">(Integer a, Integer b, BiFunction&lt;Integer, Integer, Integer&gt; bf)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> bf.apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之函数式编程-Consumer"><a href="#JDK8之函数式编程-Consumer" class="headerlink" title="JDK8之函数式编程 Consumer"></a>JDK8之函数式编程 Consumer</h2><p>Consumer 消费型接⼝：</p>
<ol>
<li>有⼊参，⽆返回值 </li>
<li>将 T 作为输⼊，不返回任何内容 </li>
<li>调⽤⽅法：void accept(T t);</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⽤途： 因为没有出参，常⽤于打印、发送短信等消费动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; consumer = obj-&gt;&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(<span class="string">"调⽤短信接⼝发送短信，或者打印⽇志"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// sendMsg("8888888",obj-&gt;&#123;</span></span><br><span class="line">    <span class="comment">// System.out.println(obj);</span></span><br><span class="line">    <span class="comment">// System.out.println("调⽤短信接⼝发送短信，或者打印⽇志");</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    sendMsg(<span class="string">"8888888"</span>,consumer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String phone,Consumer&lt;String&gt; consumer)</span></span>&#123;</span><br><span class="line">    consumer.accept(phone);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>典型应⽤，集合的foreach</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>);</span><br><span class="line">list.forEach(obj-&gt;&#123;</span><br><span class="line">	<span class="comment">//TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之函数式编程-Supplier"><a href="#JDK8之函数式编程-Supplier" class="headerlink" title="JDK8之函数式编程 Supplier"></a>JDK8之函数式编程 Supplier</h2><p><strong>Supplier: 供给型接⼝</strong></p>
<ol>
<li>⽆⼊参，有返回值 </li>
<li>T：出参类型；没有⼊参 </li>
<li>调⽤⽅法：T get();</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⽤途： 泛型⼀定和⽅法的返回值类型是⼀种类型，如果需要获得⼀个数据，并且不需要传⼊参数,可以使⽤Supplier接⼝，例如⽆参的⼯⼚⽅法，即⼯⼚设计模式创建对象，简单来说就是提供者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Student student = new Student();</span></span><br><span class="line">    Student student = newStudent();</span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">newStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Supplier&lt;Student&gt; supplier = ()-&gt; &#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"默认名称"</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之函数式编程-Predicate"><a href="#JDK8之函数式编程-Predicate" class="headerlink" title="JDK8之函数式编程 Predicate"></a>JDK8之函数式编程 Predicate</h2><p><strong>Predicate: 断⾔型接⼝</strong></p>
<ol>
<li>有⼊参，有返回值，返回值类型确定是boolean </li>
<li>T：⼊参类型；出参类型是Boolean </li>
<li>调⽤⽅法：boolean test(T t);</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⽤途： 接收⼀个参数，⽤于判断是否满⾜⼀定的条件，过滤数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"awewrwe"</span>,<span class="string">"vdssdsd"</span>,<span class="string">"aoooo"</span>,<span class="string">"psdddsd"</span>);</span><br><span class="line">    List&lt;String&gt; results = filter(list,obj-&gt;obj.startsWith(<span class="string">"a"</span>));</span><br><span class="line">    System.out.println(results);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; predicate)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(str)) &#123;</span><br><span class="line">            results.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之⽅法与构造函数引⽤"><a href="#JDK8之⽅法与构造函数引⽤" class="headerlink" title="JDK8之⽅法与构造函数引⽤"></a>JDK8之⽅法与构造函数引⽤</h2><p>以前⽅法调⽤ <strong>对象.⽅法名</strong> 或者 <strong>类名.⽅法名</strong> </p>
<p><strong>jdk1.8提供了另外⼀种调⽤⽅式 ::</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">说明:⽅法引⽤是⼀种更简洁易懂的lambda表达式，操作符是双冒号::，⽤来直接访问类或者实例已经存在的⽅法或构造⽅法</span><br><span class="line"></span><br><span class="line">通过⽅法引⽤，可以将⽅法的引⽤赋值给⼀个变量</span><br><span class="line"></span><br><span class="line">语法：左边是容器（可以是类名，实例名），中间是&quot; :: &quot;，右边是相应的⽅法名</span><br><span class="line">静态⽅法，则是ClassName::methodName。如 Object ::equals</span><br><span class="line">实例⽅法，则是Instance::methodName</span><br><span class="line">构造函数，则是 类名::new;</span><br><span class="line"></span><br><span class="line">单个参数</span><br><span class="line">Function&lt;⼊参1, 返回类型&gt; func &#x3D; ⽅法引⽤</span><br><span class="line">应⽤ func.apply(⼊参);</span><br><span class="line"></span><br><span class="line">2个参数</span><br><span class="line">BiFunction&lt;⼊参1,⼊参2, 返回类型&gt; func &#x3D; ⽅法引⽤</span><br><span class="line">应⽤ func.apply(⼊参1,⼊参2);</span><br></pre></td></tr></table></figure>

<p><strong>实战</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJdk8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使⽤双冒号::来构造静态函数引⽤</span></span><br><span class="line">        Function&lt;String, Integer&gt; fun = Integer::parseInt;</span><br><span class="line">        Integer value = fun.apply(<span class="string">"1024"</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">// 使⽤双冒号::来构造⾮静态函数引⽤</span></span><br><span class="line">        String content = <span class="string">"欢迎来到⼩滴课堂学习"</span>;</span><br><span class="line">        Function&lt;Integer, String&gt; func = content::substring;</span><br><span class="line">        String result = func.apply(<span class="number">1</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">// 构造函数引⽤，多个参数</span></span><br><span class="line">        BiFunction&lt;String, Integer, User&gt; biFunction = User::<span class="keyword">new</span>;</span><br><span class="line">        User user1 = biFunction.apply(<span class="string">"⼩滴课堂"</span>, <span class="number">28</span>);</span><br><span class="line">        System.out.println(user1.toString());</span><br><span class="line">        <span class="comment">//构造函数引⽤，单个参数</span></span><br><span class="line">        Function&lt;String, User&gt; function = User::<span class="keyword">new</span>;</span><br><span class="line">        User user2 = function.apply(<span class="string">"⼩D"</span>);</span><br><span class="line">        System.out.println(user2.toString());</span><br><span class="line">        <span class="comment">// 函数引⽤也是⼀种函数式接⼝，可以将函数引⽤作为⽅法的参数</span></span><br><span class="line">        sayHello(String::toUpperCase, <span class="string">"xdclass.net"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> func 函数引⽤</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 对应的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Function&lt;String, String&gt; func, String</span></span></span><br><span class="line"><span class="function"><span class="params">                                 param)</span> </span>&#123;</span><br><span class="line">        String result = func.apply(param);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDK8-集合框架"><a href="#JDK8-集合框架" class="headerlink" title="JDK8 集合框架"></a>JDK8 集合框架</h1><h2 id="JDK8之流Stream实战"><a href="#JDK8之流Stream实战" class="headerlink" title="JDK8之流Stream实战"></a>JDK8之流Stream实战</h2><p><strong>什么是stream？</strong></p>
<p>Stream 中⽂称为 “流”，通过将集合转换为这么⼀种叫做 “流”的元素队列，通过声明性⽅式，能够对集合中的每个元素进⾏⼀系列并⾏或串⾏的流⽔线操作，元素是特定类型的对象，所以元素集合看作⼀种流， 流在管道中传输， 且可以在管道的节点上进⾏处理， ⽐如 排序，聚合，过滤等操作</p>
<p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701114034.png" alt="image-20210701114024710"></p>
<p><strong>操作详情</strong></p>
<ol>
<li>数据元素便是原始集合，如List、Set、Map等</li>
<li>⽣成流，可以是串⾏流stream() 或者并⾏流 parallelStream() </li>
<li>中间操作，可以是 排序，聚合，过滤，转换等</li>
<li>终端操作，很多流操作本身就会返回⼀个流，所以多个操作可以直接连接起来，最后统⼀进⾏收集 </li>
<li>概览stream接⼝源码</li>
</ol>
<p><strong>快速上⼿</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot教程"</span>,<span class="string">"微服务教程"</span>,<span class="string">"并发编程"</span>,<span class="string">"压⼒测试"</span>,<span class="string">"架构课程"</span>);</span><br><span class="line">List&lt;String&gt; resultList = list.stream().map(obj-&gt;<span class="string">"在⼩滴课堂学："</span>+obj).collect(Collectors.toList());</span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之流操作map和filter函数"><a href="#JDK8之流操作map和filter函数" class="headerlink" title="JDK8之流操作map和filter函数"></a>JDK8之流操作map和filter函数</h2><p><strong>map函数</strong> </p>
<p>将流中的每⼀个元素 T 映射为 R（类似类型转换），上堂课的例⼦就是，类似遍历集合，对集合的每个对象做处理</p>
<p>场景：转换对象，如javaweb开发中集合⾥⾯的DO对象转换为DTO对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = Arrays.asList(<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"⼩东"</span>,<span class="string">"123"</span>), <span class="keyword">new</span> User(<span class="number">21</span>,<span class="string">"jack"</span>,<span class="string">"rawer"</span>), <span class="keyword">new</span> User(<span class="number">155</span>,<span class="string">"tom"</span>,<span class="string">"sadfsdfsdfsd"</span>), <span class="keyword">new</span> User(<span class="number">231</span>,<span class="string">"marry"</span>,<span class="string">"234324"</span>), <span class="keyword">new</span> User(<span class="number">100</span>,<span class="string">"⼩D"</span>,<span class="string">"122223"</span>));</span><br><span class="line">List&lt;UserDTO&gt; userDTOList = list.stream().map(obj-&gt;&#123;</span><br><span class="line">    UserDTO userDTO = <span class="keyword">new</span> UserDTO(obj.getId(),obj.getName());</span><br><span class="line">    <span class="keyword">return</span> userDTO;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line">System.out.println(userDTOList);</span><br></pre></td></tr></table></figure>

<p><strong>filter函数</strong></p>
<p>⽤于通过设置的条件过滤出元素 </p>
<p>需求：过滤出字符串⻓度⼤于5的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>, <span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line">List&lt;String&gt; resultList = list.stream().filter(obj -&gt; obj.length() &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure>

<p>场景：主要⽤于筛选过滤出符合条件的元素</p>
<h2 id="JDK8之流操作limit和sorted函数"><a href="#JDK8之流操作limit和sorted函数" class="headerlink" title="JDK8之流操作limit和sorted函数"></a>JDK8之流操作limit和sorted函数</h2><p><strong>sorted函数：sorted() 对流进⾏⾃然排序, 其中的元素必须实现Comparable 接⼝</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>, <span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line">List&lt;String&gt; resultList = list.stream().sorted().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><strong>sorted(Comparator comparator) ⽤来⾃定义升降序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>,</span><br><span class="line"><span class="string">"redis"</span>, <span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line"><span class="comment">//根据⻓度进⾏排序</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; resultList = list.stream().sorted(Comparator.comparing(obj -&gt; obj.length())).collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; resultList = list.stream().sorted(Comparator.comparing(obj -&gt; obj.length(),Comparator.reverseOrder())).</span></span><br><span class="line"><span class="comment">//    collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; resultList = list.stream().sorted(Comparator.comparing(String::length).reversed()).collect(Collectors.toList());</span></span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure>

<p><strong>limit函数：截断流使其最多只包含指定数量的元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>, <span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line"><span class="comment">//limit截取</span></span><br><span class="line">List&lt;String&gt; resultList = list.stream().sorted(Comparator.comparing(String::length).reversed()).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(resultList);</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之流操作allMatch和anyMatch函数"><a href="#JDK8之流操作allMatch和anyMatch函数" class="headerlink" title="JDK8之流操作allMatch和anyMatch函数"></a>JDK8之流操作allMatch和anyMatch函数</h2><p><strong>allMatch函数：检查是否匹配所有元素，只有全部符合才返回true</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>,</span><br><span class="line"><span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = list.stream().allMatch(obj-&gt;obj.length()&gt;<span class="number">1</span>);</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure>

<p><strong>anyMatch函数：检查是否⾄少匹配⼀个元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"springboot"</span>, <span class="string">"springcloud"</span>, <span class="string">"redis"</span>,</span><br><span class="line"><span class="string">"git"</span>, <span class="string">"netty"</span>, <span class="string">"java"</span>, <span class="string">"html"</span>, <span class="string">"docker"</span>);</span><br><span class="line"><span class="keyword">boolean</span> flag = list.stream().anyMatch(obj-&gt;obj.length()&gt;<span class="number">18</span>);</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure>

<p>先看⽅法⼊参，返回值，再看⽅法描述</p>
<h2 id="JDK8之流操作max和min函数"><a href="#JDK8之流操作max和min函数" class="headerlink" title="JDK8之流操作max和min函数"></a>JDK8之流操作max和min函数</h2><p>max和min函数 最⼤值和最⼩值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = Arrays.asList(<span class="keyword">new</span> Student(<span class="number">32</span>),<span class="keyword">new</span> Student(<span class="number">33</span>),<span class="keyword">new</span> Student(<span class="number">21</span>),<span class="keyword">new</span> Student(<span class="number">29</span>),<span class="keyword">new</span> Student(<span class="number">18</span>));</span><br><span class="line"><span class="comment">//list.stream().max(Comparator.comparingInt(Student::getAge));</span></span><br><span class="line"><span class="comment">//最⼤</span></span><br><span class="line">Optional&lt;Student&gt; optional = list.stream().max((s1, s2)-&gt;Integer.compare(s1.getAge(),s2.getAge()));</span><br><span class="line"><span class="comment">//最⼩</span></span><br><span class="line">Optional&lt;Student&gt; optional = list.stream().min((s1, s2)-&gt;Integer.compare(s1.getAge(),s2.getAge()));</span><br><span class="line">System.out.println(optional.get().getAge());</span><br></pre></td></tr></table></figure>

<h1 id="JDK8-集合框架进阶"><a href="#JDK8-集合框架进阶" class="headerlink" title="JDK8 集合框架进阶"></a>JDK8 集合框架进阶</h1><h2 id="JDK8之并⾏流parallelStream"><a href="#JDK8之并⾏流parallelStream" class="headerlink" title="JDK8之并⾏流parallelStream"></a>JDK8之并⾏流parallelStream</h2><p><strong>为什么会有这个并⾏流</strong> </p>
<p>集合做重复的操作，如果使⽤串⾏执⾏会相当耗时，因此⼀般会采⽤多线程来加快，Java8的 paralleStream⽤fork/join框架提供了并发执⾏能⼒ </p>
<p>底层原理：线程池(ForkJoinPool)维护⼀个线程队列 可以分割任务，将⽗任务拆分成⼦任务，完全贴合分治思想 </p>
<p><strong>两个区别</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序输出</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.stream().forEach(System.out::println);</span><br><span class="line"><span class="comment">//并⾏乱序输出</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">numbers.parallelStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>paralleStream并⾏是否⼀定⽐Stream串⾏快？</strong> </p>
<p>错误，数据量少的情况，可能串⾏更快，ForkJoin会耗性能，多数情况下并⾏⽐串⾏快，是否可以都⽤并⾏？不⾏，部分情况会有线程安全问题，parallelStream⾥⾯使⽤的外部变量，⽐如集合⼀定要使⽤线程安全集合，不然就会引发多线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">//List list = new CopyOnWriteArrayList();</span></span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">100</span>).parallel().forEach(list::add);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701122255.png" alt="image-20210701122253062"></p>
<p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701122331.png" alt="image-20210701122328687"></p>
<h2 id="JDK8之reduce操作"><a href="#JDK8之reduce操作" class="headerlink" title="JDK8之reduce操作"></a>JDK8之reduce操作</h2><p>什么是reduce操作？</p>
<ol>
<li><p>聚合操作，中⽂意思是 “减少” </p>
</li>
<li><p>根据⼀定的规则将Stream中的元素进⾏计算后返回⼀个唯⼀的值 </p>
</li>
<li><p>常⽤⽅法⼀</p>
<p>accumulator：计算的累加器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例⼦: 第⼀个元素相加和第⼆个元素相加，结果再和第三个元素相加，直到全部相加完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).reduce((item1, item2) -&gt; item1 + item2).get();</span><br></pre></td></tr></table></figure>

<p>不⽤lambda的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).reduce(<span class="keyword">new</span> BinaryOperator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer item1, Integer item2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item1 + item2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure>
</li>
<li><p>常⽤⽅法⼆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure>

<p>identity ⽤户提供⼀个循环计算的初始值 </p>
<p>accumulator 计算的累加器 </p>
<p>例⼦： 100作为初始值，然后和第⼀个元素相加，结果在和第⼆个元素相加，直到全部 相加完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>).reduce(<span class="number">100</span>, (sum, item) -&gt; sum + item);</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习 ： 求最⼤值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = Stream.of(<span class="number">1645</span>, <span class="number">234345</span>, <span class="number">32</span>, <span class="number">44434</span>,<span class="number">564534</span>,<span class="number">435</span>,<span class="number">34343542</span>,<span class="number">212</span>).reduce( (item1, item2) -&gt; item1 &gt; item2 ? item1 : item2 ).get();</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="JDK8之集合的foreach"><a href="#JDK8之集合的foreach" class="headerlink" title="JDK8之集合的foreach"></a>JDK8之集合的foreach</h2><p>集合遍历的⽅式 </p>
<ol>
<li>for循环 </li>
<li>迭代器 Iterator</li>
</ol>
<p><strong>Jdk8⾥⾯的新增接⼝</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; results = Arrays.asList(<span class="keyword">new</span> Student(<span class="number">32</span>),<span class="keyword">new</span> Student(<span class="number">33</span>),<span class="keyword">new</span> Student(<span class="number">21</span>),<span class="keyword">new</span> Student(<span class="number">29</span>),<span class="keyword">new</span> Student(<span class="number">18</span>));</span><br><span class="line">results.forEach(obj-&gt;&#123;</span><br><span class="line">    System.out.println(obj.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>不能修改包含外部的变量的值 </li>
<li>不能⽤break或者return或者continue等关键词结束或者跳过循环</li>
</ol>
<h1 id="JDK8-收集器和集合统计"><a href="#JDK8-收集器和集合统计" class="headerlink" title="JDK8 收集器和集合统计"></a>JDK8 收集器和集合统计</h1><h2 id="JDK8之collector收集器"><a href="#JDK8之collector收集器" class="headerlink" title="JDK8之collector收集器"></a>JDK8之collector收集器</h2><p>collect()⽅法的作⽤ </p>
<ol>
<li><p>⼀个终端操作, ⽤于对流中的数据进⾏归集操作，collect⽅法接受的参数是⼀个Collector </p>
</li>
<li><p>有两个重载⽅法，在Stream接⼝⾥⾯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载⽅法⼀</span></span><br><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator, BiConsumer&lt;R, R&gt;combiner)</span></span>;</span><br><span class="line"><span class="comment">//重载⽅法⼆</span></span><br><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Collector的作⽤：就是收集器，也是⼀个接⼝, 它的⼯具类Collectors提供了很多⼯⼚⽅法</p>
</li>
<li><p>Collectors的作⽤：⼯具类，提供了很多常⻅的收集器实现</p>
<p>Collectors.toList()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,(left, right) -&gt; &#123;</span><br><span class="line">        left.addAll(right); </span><br><span class="line">        <span class="keyword">return</span> left; </span><br><span class="line">    &#125;, CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList::new，创建⼀个ArrayList作为累加器 </p>
<p>List::add，对流中元素的操作就是直接添加到累加器中 r</p>
<p>reduce操作, 对⼦任务归集结果addAll，后⼀个⼦任务的结果直接全部添加到前⼀个⼦任务结果中 </p>
<p>CH_ID 是⼀个unmodifiableSet集合</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collectors.toMap() </span><br><span class="line">Collectors.toSet() </span><br><span class="line">Collectors.toCollection() ：⽤⾃定义的实现Collection的数据结构收集 	</span><br><span class="line"></span><br><span class="line">Collectors.toCollection(LinkedList::new) </span><br><span class="line">Collectors.toCollection(CopyOnWriteArrayList::new) </span><br><span class="line">Collectors.toCollection(TreeSet::new)</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之joining函数"><a href="#JDK8之joining函数" class="headerlink" title="JDK8之joining函数"></a>JDK8之joining函数</h2><p>拼接函数 Collectors.joining</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3种重载⽅法</span></span><br><span class="line">Collectors.joining()</span><br><span class="line">Collectors.joining(<span class="string">"param"</span>)</span><br><span class="line">Collectors.joining(<span class="string">"param1"</span>, <span class="string">"param2"</span>, <span class="string">"param3"</span>)</span><br></pre></td></tr></table></figure>

<p>其中⼀个的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">        StringBuilder::<span class="keyword">new</span>, </span><br><span class="line">        StringBuilder::append,</span><br><span class="line">        (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">        StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： 该⽅法可以将Stream得到⼀个字符串， joining函数接受三个参数时，分别表示元素之间的连接符、前缀和后缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = Stream.of(<span class="string">"springboot"</span>, <span class="string">"mysql"</span>, <span class="string">"html5"</span>, <span class="string">"css3"</span>).collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之收集器-partitioningBy分组"><a href="#JDK8之收集器-partitioningBy分组" class="headerlink" title="JDK8之收集器 partitioningBy分组"></a>JDK8之收集器 partitioningBy分组</h2><p>Collectors.partitioningBy 分组，key是boolean类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate) &#123;</span><br><span class="line">    <span class="keyword">return</span> partitioningBy(predicate, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习： 根据list⾥⾯进⾏分组，字符串⻓度⼤于4的为⼀组，其他为另外⼀组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"java"</span>, <span class="string">"springboot"</span>,<span class="string">"HTML5"</span>,<span class="string">"nodejs"</span>,<span class="string">"CSS3"</span>);</span><br><span class="line">Map&lt;Boolean, List&lt;String&gt;&gt; result = list.stream().collect(partitioningBy(obj -&gt; obj.length() &gt; <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之收集器-group-by分组"><a href="#JDK8之收集器-group-by分组" class="headerlink" title="JDK8之收集器 group by分组"></a>JDK8之收集器 group by分组</h2><p>分组 Collectors.groupingBy()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123; </span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习：根据学⽣所在的省份，进⾏分组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">24</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>),<span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">22</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>),<span class="keyword">new</span> Student(<span class="string">"海南"</span>, <span class="number">25</span>));</span><br><span class="line">Map&lt;String, List&lt;Student&gt;&gt; listMap = students.stream().collect(Collectors.groupingBy(obj -&gt; obj.getProvince()));</span><br><span class="line">listMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"========"</span>);</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    value.forEach(obj -&gt; &#123;</span><br><span class="line">        System.out.println(obj.getAge());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> province;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(String province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String province, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之收集器-group-by进阶"><a href="#JDK8之收集器-group-by进阶" class="headerlink" title="JDK8之收集器 group by进阶"></a>JDK8之收集器 group by进阶</h2><p>分组统计</p>
<ol>
<li>聚合函数进⾏统计查询，分组后统计个数 </li>
<li>Collectors.counting() 统计元素个数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line"> 	<span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求：统计各个省份的⼈数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">24</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>),<span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">22</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>),<span class="keyword">new</span> Student(<span class="string">"海南"</span>, <span class="number">25</span>));</span><br><span class="line">Map&lt;String, Long&gt; listMap = students.stream().collect(Collectors.groupingBy(Student::getProvince,</span><br><span class="line">                                                    Collectors.counting()));</span><br><span class="line">listMap.forEach((key, value) -&gt; &#123;System.out.println(key+<span class="string">"省⼈数有"</span>+value);&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="JDK8之summarizing集合统计"><a href="#JDK8之summarizing集合统计" class="headerlink" title="JDK8之summarizing集合统计"></a>JDK8之summarizing集合统计</h2><p>summarizing 统计相关, 下⾯是summarizingInt的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;T, IntSummaryStatistics, IntSummaryStatistics&gt;(</span><br><span class="line">    IntSummaryStatistics::<span class="keyword">new</span>,</span><br><span class="line">    (r, t) -&gt; r.accept(mapper.applyAsInt(t)),</span><br><span class="line">    (l, r) -&gt; &#123; l.combine(r); <span class="keyword">return</span> l; &#125;, CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作⽤：可以⼀个⽅法把统计相关的基本上都完成</p>
<p>分类 </p>
<ol>
<li>summarizingInt </li>
<li>summarizingLong </li>
<li>summarizingDouble</li>
</ol>
<p>需求：统计学⽣的各个年龄信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">24</span>), <span class="keyword">new</span> Student(<span class="string">"⼴东"</span>, <span class="number">23</span>),<span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">22</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>), <span class="keyword">new</span> Student(<span class="string">"北京"</span>, <span class="number">20</span>),<span class="keyword">new</span> Student(<span class="string">"海南"</span>, <span class="number">25</span>));</span><br><span class="line">IntSummaryStatistics summaryStatistics = students.stream().collect(Collectors.summarizingInt(Student::getAge));</span><br><span class="line">System.out.println(<span class="string">"平均值："</span> + summaryStatistics.getAverage());</span><br><span class="line">System.out.println(<span class="string">"⼈数："</span> + summaryStatistics.getCount());</span><br><span class="line">System.out.println(<span class="string">"最⼤值："</span> + summaryStatistics.getMax());</span><br><span class="line">System.out.println(<span class="string">"最⼩值："</span> + summaryStatistics.getMin());</span><br><span class="line">System.out.println(<span class="string">"总和："</span> + summaryStatistics.getSum());</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProvince</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> province;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProvince</span><span class="params">(String province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String province, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDK8-Collection和Lambda实战"><a href="#JDK8-Collection和Lambda实战" class="headerlink" title="JDK8 Collection和Lambda实战"></a>JDK8 Collection和Lambda实战</h1><h2 id="Collection和Lambda电商数据处理实战需求说明"><a href="#Collection和Lambda电商数据处理实战需求说明" class="headerlink" title="Collection和Lambda电商数据处理实战需求说明"></a>Collection和Lambda电商数据处理实战需求说明</h2><p>需求描述：电商订单数据处理，根据下⾯的videoOrders1 5个订单 和videoOrders2 6个订单 </p>
<ol>
<li>统计出同时被两个⼈购买的商品列表(交集) </li>
<li>统计出两个⼈购买商品的差集 </li>
<li>统计出全部被购买商品的去重并集 </li>
<li>统计两个⼈的分别购买订单的平均价格</li>
<li>统计两个⼈的分别购买订单的总价格</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总价 35</span></span><br><span class="line"> List&lt;VideoOrder&gt; videoOrders1 = Arrays.asList(</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20190242812"</span>, <span class="string">"springboot教程"</span>, <span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20194350812"</span>, <span class="string">"微服务SpringCloud"</span>, <span class="number">5</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20190814232"</span>, <span class="string">"Redis教程"</span>, <span class="number">9</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20190523812"</span>, <span class="string">"⽹⻚开发教程"</span>, <span class="number">9</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"201932324"</span>, <span class="string">"百万并发实战Netty"</span>, <span class="number">9</span>));</span><br><span class="line"> <span class="comment">//总价 54</span></span><br><span class="line"> List&lt;VideoOrder&gt; videoOrders2 = Arrays.asList(</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019024285312"</span>, <span class="string">"springboot教程"</span>, <span class="number">3</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019081453232"</span>, <span class="string">"Redis教程"</span>, <span class="number">9</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"20190522338312"</span>, <span class="string">"⽹⻚开发教程"</span>, <span class="number">9</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019435230812"</span>, <span class="string">"Jmeter压⼒测试"</span>, <span class="number">5</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019323542411"</span>, <span class="string">"Git+Jenkins持续集成"</span>, <span class="number">7</span>),</span><br><span class="line"> <span class="keyword">new</span> VideoOrder(<span class="string">"2019323542424"</span>, <span class="string">"Idea全套教程"</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String tradeNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoOrder</span><span class="params">(String tradeNo,String title, <span class="keyword">int</span> money )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tradeNo = tradeNo;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTradeNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tradeNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTradeNo</span><span class="params">(String tradeNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tradeNo = tradeNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理电商订单数据的答案"><a href="#处理电商订单数据的答案" class="headerlink" title="处理电商订单数据的答案"></a>处理电商订单数据的答案</h2><p>使⽤jdk8新特性完成订单需求1，2，3</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改VideoOrder</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> VideoOrder) &#123;</span><br><span class="line">        VideoOrder o1 = (VideoOrder)obj;</span><br><span class="line">        <span class="keyword">return</span> title.equals(o1.getTitle());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"VideoOrder&#123;"</span> +</span><br><span class="line">        <span class="string">"money="</span> + money +</span><br><span class="line">        <span class="string">", title='"</span> + title + <span class="string">'\''</span> +</span><br><span class="line">        <span class="string">'&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line">List&lt;VideoOrder&gt; intersectionList = videoOrders1.stream().filter(videoOrders2::contains).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"交集="</span>+intersectionList);</span><br><span class="line"><span class="comment">//差集1</span></span><br><span class="line">List&lt;VideoOrder&gt; diffList1 = videoOrders1.stream().filter(obj-&gt;!videoOrders2.contains(obj)).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"差集1="</span>+diffList1);</span><br><span class="line"><span class="comment">//差集2</span></span><br><span class="line">List&lt;VideoOrder&gt; diffList2 = videoOrders2.stream().filter(obj-&gt;!videoOrders1.contains(obj)).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"差集2="</span>+diffList2);</span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">List&lt;VideoOrder&gt; allVideoOrder = videoOrders1.parallelStream().collect(Collectors.toList());</span><br><span class="line">allVideoOrder.addAll(videoOrders2);</span><br><span class="line">System.out.println(<span class="string">"并集 = "</span>+allVideoOrder);</span><br><span class="line"><span class="comment">//去重并集</span></span><br><span class="line">List&lt;VideoOrder&gt; allVideoOrderDistinct = allVideoOrder.stream().distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"去重并集 = "</span>+allVideoOrderDistinct);</span><br></pre></td></tr></table></figure>

<p>使⽤jdk8新特性完成订单需求4，5</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个订单平均价格</span></span><br><span class="line"><span class="keyword">double</span> videoOrderAvg1 = videoOrders1.stream().collect(Collectors.averagingInt(VideoOrder::getMoney)).doubleValue();</span><br><span class="line">System.out.println(<span class="string">"订单列表1平均价格="</span>+videoOrderAvg1);</span><br><span class="line"><span class="keyword">double</span> videoOrderAvg2 = videoOrders2.stream().collect(Collectors.averagingInt(VideoOrder::getMoney)).doubleValue();</span><br><span class="line">System.out.println(<span class="string">"订单列表2平均价格="</span>+videoOrderAvg2);</span><br><span class="line"><span class="comment">//订单总价</span></span><br><span class="line"><span class="keyword">int</span> totalMoney1 = videoOrders1.stream().collect(Collectors.summingInt(VideoOrder::getMoney)).intValue();</span><br><span class="line"><span class="keyword">int</span> totalMoney2 = videoOrders2.stream().collect(Collectors.summingInt(VideoOrder::getMoney)).intValue();</span><br><span class="line">System.out.println(<span class="string">"订单列表1总价="</span>+totalMoney1);</span><br><span class="line">System.out.println(<span class="string">"订单列表2总价="</span>+totalMoney2);</span><br></pre></td></tr></table></figure>

<h1 id="JDK8-新的内存空间和异常处理"><a href="#JDK8-新的内存空间和异常处理" class="headerlink" title="JDK8 新的内存空间和异常处理"></a>JDK8 新的内存空间和异常处理</h1><h2 id="JDK8新特性之新内存空间Matespace"><a href="#JDK8新特性之新内存空间Matespace" class="headerlink" title="JDK8新特性之新内存空间Matespace"></a>JDK8新特性之新内存空间Matespace</h2><p>JVM 种类有很多，⽐如 Oralce-Sun Hotspot，Oralce JRockit，IBM J9，Taobao JVM，我们讲的是 Hotspot才有，JRockit以及J9是没有这个区域 </p>
<p>JVM内存知识：在JDK8之前的HotSpot JVM，有个区域叫做“永久代(permanent generation)，通过在命令⾏设置参数-XX:MaxPermSize来设定永久代最⼤可分配的内存空间 </p>
<p>如果JDK8⾥⾯设置了PermSize 和 MaxPermSize 会被忽略并给出警告 </p>
<p>新内存空间Matespace作⽤：该块内存主要是被JVM⽤来存放 class 和 mate 信息的，当 class 被加载 loader 的时候就会 被存储到该内存区中，如⽅法的编译信息及字节码、常量池和符号解析、类的层级信息，字段，名字等 </p>
<p>有⼤项⽬经验的同学对下⾯这个异常应该熟悉 java.lang.OutOfMemoryError: PermGen space 原因是: 永久代空间不够，类太多导致</p>
<p> jdk8的修改：JDK8 HotSpot JVM 使⽤本地内存来存储类元数据信息，叫做元空间（Metaspace） 在默认情况下Metaspace的⼤⼩只与本地内存⼤⼩有关 常⽤的两个参数 -XX:MetaspaceSize=N 指Metaspace扩容时触发FullGC的初始化阈值 -XX:MaxMetaspaceSize=N 指⽤于限制Metaspace增⻓的上限，防⽌因为某些情况导致 Metaspace⽆限的使⽤本地内存，不管两个参数如何设置，都会从20.8M开始，然后随着类加载越来越多不断扩容调整直到最⼤ </p>
<p><strong>查看⼤⼩ jstat -gc pid</strong> </p>
<ol>
<li>MC: current metaspace capacity </li>
<li>MU: mateaspace utilization 单位是KB</li>
</ol>
<h2 id="JDK7新特性之try-with-resources"><a href="#JDK7新特性之try-with-resources" class="headerlink" title="JDK7新特性之try-with-resources"></a>JDK7新特性之try-with-resources</h2><p>什么是try-with-resources？资源的关闭很多⼈停留在旧的流程上，jdk7新特性就有，但是很多⼈以为是jdk8的 在try( …)⾥声明的资源，会在try-catch代码块结束后⾃动关闭掉</p>
<p>旧的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String path = <span class="string">"/Users/jack/Desktop/t.txt"</span>;</span><br><span class="line">    test(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out.write((filepath+<span class="string">"可以学习java架构课程"</span>).getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String filepath)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);) &#123;</span><br><span class="line">        out.write((filepath+<span class="string">"可以学习java架构课程"</span>).getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ol>
<li>实现了AutoCloseable接⼝的类，在try()⾥声明该类实例的时候，try结束后⾃动调⽤的 close⽅法，这个动作会早于finally⾥调⽤的⽅法</li>
<li>不管是否出现异常，try()⾥的实例都会被调⽤close⽅法</li>
<li>try⾥⾯可以声明多个⾃动关闭的对象，越早声明的对象，会越晚被close掉</li>
</ol>
<h1 id="JDK9常⻅特性"><a href="#JDK9常⻅特性" class="headerlink" title="JDK9常⻅特性"></a>JDK9常⻅特性</h1><h2 id="jdk9新增测试⼯具jshell"><a href="#jdk9新增测试⼯具jshell" class="headerlink" title="jdk9新增测试⼯具jshell"></a>jdk9新增测试⼯具jshell</h2><p>什么是jshell？</p>
<p>从java9开始，jdk引⼊了交互式 REPL（Read-Eval-Print-Loop，读取-求值-输出-循环） </p>
<p>官⽅⽂档 <a href="https://docs.oracle.com/en/java/javase/12/jshell/introduction-jshell.html#GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/jshell/introduction-jshell.html#GUID-630F27C8-1195-4989-9F6B-2C51D46F52C8</a></p>
<p>常⽤命令 帮助命令/help /help intro </p>
<p>列出输⼊的源 /list </p>
<p>编辑某个源 /edit </p>
<p>删除 /drop </p>
<p>退出jshell命令 /exit</p>
<p>重置 /reset </p>
<p>查看历史编辑 /history</p>
<p>⾃动化补⻬功能 Tab键</p>
<h2 id="接⼝⽅法进阶之JDK9私有⽅法"><a href="#接⼝⽅法进阶之JDK9私有⽅法" class="headerlink" title="接⼝⽅法进阶之JDK9私有⽅法"></a>接⼝⽅法进阶之JDK9私有⽅法</h2><p>什么是jdk9新增的接⼝私有⽅法 </p>
<ul>
<li>JDK8新增了静态⽅法和默认⽅法，但是不⽀持私有⽅法 </li>
<li>jdk9中新增了私有⽅法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderPay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultPay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接⼝的私有⽅法可以在JDK9中使⽤</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调⽤接⼝的私有⽅法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPayImpl</span> <span class="keyword">implements</span> <span class="title">OrderPay</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我实现了接⼝"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    OrderPay orderPay = <span class="keyword">new</span> OrderPayImpl();</span><br><span class="line">    orderPay.defaultPay();</span><br><span class="line">    orderPay.pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点（⾯试题！！！）：</p>
<ol>
<li>接⼝中的静态⽅法不能被实现类继承和⼦接⼝继承，但是接⼝中的⾮静态的默认⽅法可以被实现类继承 </li>
<li>例如List.of() ⽅法，ArrayList虽然继承了List，但是不能⽤ArrayList.of()⽅法 </li>
<li>类的静态⽅法可以被继承</li>
</ol>
<h2 id="JDK9新特性之增强try-with-resource"><a href="#JDK9新特性之增强try-with-resource" class="headerlink" title="JDK9新特性之增强try-with-resource"></a>JDK9新特性之增强try-with-resource</h2><p>什么是try-with-resource </p>
<p>在JDK7中，新增了try-with-resources语句，可以在try后的括号中初始化资源，可以实现资源⾃动关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line"><span class="keyword">try</span>(OutputStream temp = out;) &#123;</span><br><span class="line">    temp.write((filepath+<span class="string">"可以学习java架构课程"</span>).getBytes());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么是增强try-with-resource</p>
<ol>
<li>在JDK9中，改进了try-with-resources语句，在try外进⾏初始化，在括号内引⽤，即可实现资源⾃动关闭，多个变量则⽤分号进⾏分割 </li>
<li>不需要声明资源 out 就可以使⽤它，并得到相同的结果</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/Users/xdclass/Desktop/t.txt"</span>;</span><br><span class="line">    test(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(filepath);</span><br><span class="line">    <span class="keyword">try</span> (out) &#123;</span><br><span class="line">        out.write((filepath + <span class="string">"可以学习java架构课程"</span>).getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDK9的Stream和集合API"><a href="#JDK9的Stream和集合API" class="headerlink" title="JDK9的Stream和集合API"></a>JDK9的Stream和集合API</h1><h2 id="JDK9之快速创建只读集合"><a href="#JDK9之快速创建只读集合" class="headerlink" title="JDK9之快速创建只读集合"></a>JDK9之快速创建只读集合</h2><p>什么是只读集合：集合只能读取，不能增加或者删除⾥⾯的元素</p>
<p>JDK9之前创建只读集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"SpringBoot课程"</span>);</span><br><span class="line">list.add(<span class="string">"架构课程"</span>);</span><br><span class="line">list.add(<span class="string">"微服务SpringCloud课程"</span>);</span><br><span class="line"><span class="comment">//设置为只读List集合</span></span><br><span class="line">list = Collections.unmodifiableList(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(<span class="string">"Mysql教程"</span>);</span><br><span class="line">set.add(<span class="string">"Linux服务器教程"</span>);</span><br><span class="line">set.add(<span class="string">"Git教程"</span>);</span><br><span class="line"><span class="comment">//设置为只读Set集合</span></span><br><span class="line">set = Collections.unmodifiableSet(set);</span><br><span class="line">System.out.println(set);</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"key1"</span>, <span class="string">"课程1"</span>);</span><br><span class="line">map.put(<span class="string">"key2"</span>, <span class="string">"课程2"</span>);</span><br><span class="line"><span class="comment">//设置为只读Map集合</span></span><br><span class="line">map = Collections.unmodifiableMap(map);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>JDK9后创建只读集合 </p>
<ul>
<li>查看of()源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"SpringBoot课程"</span>, <span class="string">"架构课程"</span>, <span class="string">"微服务SpringCloud课程"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">"Mysql教程"</span>, <span class="string">"Linux服务器教程"</span>, <span class="string">"Git教程"</span>);</span><br><span class="line">System.out.println(set);</span><br><span class="line">Map&lt;String, String&gt; map = Map.of(<span class="string">"key1"</span>, <span class="string">"课程1"</span>, <span class="string">"key2"</span>, <span class="string">"课程2"</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<h2 id="JDK9之新增Stream-API"><a href="#JDK9之新增Stream-API" class="headerlink" title="JDK9之新增Stream API"></a>JDK9之新增Stream API</h2><p><strong>takeWhile</strong> </p>
<p>有序的集合：从 Stream 中获取⼀部分数据, 返回从头开始的尽可能多的元素, 直到遇到第⼀ 个false结果，如果第⼀个值不满⾜断⾔条件，将返回⼀个空的 Stream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"springboot"</span>,<span class="string">"java"</span>,<span class="string">"html"</span>,<span class="string">""</span>,<span class="string">"git"</span>).stream().takeWhile(obj-&gt;!obj.isEmpty()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//⽆序集合，返回元素不固定，暂⽆⽆实际使⽤场景</span></span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">"springboot"</span>,<span class="string">"java"</span>,<span class="string">"html"</span>,<span class="string">""</span>,<span class="string">"git"</span>).stream().takeWhile(obj-&gt;!obj.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><strong>dropWhile</strong></p>
<p>与 takeWhile相反，返回剩余的元素，和takeWhile⽅法形成互补</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"springboot"</span>,<span class="string">"java"</span>,<span class="string">"html"</span>,<span class="string">""</span>,<span class="string">"git"</span>).stream().dropWhile(obj-&gt;!obj.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>⽆序Stream⾥⾯也⽆实际使⽤场景</p>
<p>bug 计划在jdk10⾥⾯进⾏修复 <a href="https://bugs.openjdk.java.net/browse/JDK-8193856" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8193856</a></p>
<h1 id="JDK10和JDK11常⻅特性"><a href="#JDK10和JDK11常⻅特性" class="headerlink" title="JDK10和JDK11常⻅特性"></a>JDK10和JDK11常⻅特性</h1><h2 id="JDK10之局部变量类型推断var"><a href="#JDK10之局部变量类型推断var" class="headerlink" title="JDK10之局部变量类型推断var"></a>JDK10之局部变量类型推断var</h2><p>Java是⼀种强类型，许多流⾏的编程语⾔都已经⽀持局部变量类型推断，如js，Python，C++等</p>
<p>JDK10 可以使⽤var作为局部变量类型推断标识符 Local-Variable Type Inference（局部变量类型推断），顾名思义只能⽤做为局部变量 </p>
<p>注意 </p>
<ol>
<li>仅适⽤于局部变量，如 增强for循环的索引，传统for循环局部变量 </li>
<li>不能使⽤于⽅法形参、构造函数形参、⽅法返回类型或任何其他类型的变量声明 </li>
<li>标识符var不是关键字，⽽是⼀个保留类型名称，⽽且不⽀持类或接⼝叫var,也不符合命名规范 </li>
<li>可以⽤jshell试验或者IDEA</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据推断为 字符串类型</span></span><br><span class="line"><span class="keyword">var</span> strVar = <span class="string">"springboot"</span>;</span><br><span class="line">System.out.println(strVar <span class="keyword">instanceof</span> String);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据10L 推断long 类型</span></span><br><span class="line"><span class="keyword">var</span> longVar = <span class="number">10L</span>;</span><br><span class="line"><span class="comment">//根据 true推断 boolean 类型</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//var flag = Boolean.valueOf("true");</span></span><br><span class="line"><span class="comment">//System.out.println(flag instanceof Boolean);</span></span><br><span class="line"><span class="comment">// 推断 ArrayList&lt;String&gt;</span></span><br><span class="line"><span class="keyword">var</span> listVar = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">System.out.println(listVar <span class="keyword">instanceof</span> ArrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断 Stream&lt;String&gt;</span></span><br><span class="line"><span class="keyword">var</span> streamVar = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>);</span><br><span class="line">System.out.println(streamVar <span class="keyword">instanceof</span> Stream);</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    System.out.println(<span class="string">"这个是 flag 变量，值为true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> input = <span class="keyword">new</span> FileInputStream(<span class="string">"validation.txt"</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK11之新增HttpClient客户端快速⼊⻔"><a href="#JDK11之新增HttpClient客户端快速⼊⻔" class="headerlink" title="JDK11之新增HttpClient客户端快速⼊⻔"></a>JDK11之新增HttpClient客户端快速⼊⻔</h2><p>这个功能在JDK 9中引⼊并在JDK 10中得到了更新 </p>
<p>最终JDK11正式发布，⽀持 HTT/1.1, HTTP/2</p>
<p>官⽅⽂档 <a href="http://openjdk.java.net/jeps/321" target="_blank" rel="noopener">http://openjdk.java.net/jeps/321</a></p>
<p><strong>常⽤类和接⼝讲解</strong> </p>
<ol>
<li>HttpClient.Builder——HttpClient 构建⼯具类 </li>
<li>HttpRequest.Builder——HttpRequest 构建⼯具类 </li>
<li>HttpRequest.BodyPublisher——将java对象转换为可发送的HTTP request body字节流, 如form表单提交</li>
<li>HttpResponse.BodyHandler——处理接收到的 Response Body</li>
</ol>
<p>创建HttpClient, 下⾯结果是⼀致的底层调⽤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var httpClient = HttpClient.newBuilder().build();</span></span><br><span class="line"> <span class="keyword">var</span> httpClient = HttpClient.newHttpClient();</span><br></pre></td></tr></table></figure>

<p>创建get请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//private static final String targetUrl = "http://api.xdclass.net/pub/api/v1/web/all_category";</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> URI uri = URI.create(targetUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GET请求</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//var httpClient = HttpClient.newHttpClient();</span></span><br><span class="line">    <span class="comment">//设置建⽴连接超时 connect timeout</span></span><br><span class="line">    <span class="keyword">var</span> httpClient = HttpClient.newBuilder().connectTimeout(Duration.ofMillis(<span class="number">5000</span>)).build();</span><br><span class="line">    <span class="comment">//设置读取数据超时 read timeout</span></span><br><span class="line">    <span class="keyword">var</span> request =</span><br><span class="line">        HttpRequest.newBuilder().timeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">        .header(<span class="string">"key1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">        .header(<span class="string">"key2"</span>, <span class="string">"v2"</span>)</span><br><span class="line">        .uri(uri)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK11之标准HttpClient提交Post和异步请求"><a href="#JDK11之标准HttpClient提交Post和异步请求" class="headerlink" title="JDK11之标准HttpClient提交Post和异步请求"></a>JDK11之标准HttpClient提交Post和异步请求</h2><p>使⽤HttpClient提交Post请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String targetUrl=<span class="string">"https://api.xdclass.net/pub/api/v1/web/web_login"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> URI uri = URI.create(targetUrl);</span><br><span class="line"><span class="comment">//POST请求</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> httpClient = HttpClient.newHttpClient();</span><br><span class="line">    <span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">        .uri(uri)</span><br><span class="line">        <span class="comment">//json格式则使⽤下⾯数据</span></span><br><span class="line">        <span class="comment">//.header("Content-Type", "application/json")</span></span><br><span class="line">        <span class="comment">//.POST(HttpRequest.BodyPublishers.ofString("&#123;\"phone\":\"13113777337\",\"pwd\":\"1234567890\"&#125;"))</span></span><br><span class="line">        <span class="comment">//form表单则使⽤下⾯配置</span></span><br><span class="line">        .header(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-formurlencoded"</span>)</span><br><span class="line"></span><br><span class="line">        .POST(HttpRequest.BodyPublishers.ofString(<span class="string">"phone=13113777337&amp;pwd=1234567890"</span>))</span><br><span class="line">                                                  .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> response = httpClient.send(request,HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使⽤HttpClient提交异步GET请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步GET请求</span></span><br><span class="line"><span class="comment">//private static final String targetUrl ="http://api.xdclass.net/pub/api/v1/web/all_category";</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> URI uri = URI.create(targetUrl);</span><br><span class="line"><span class="comment">//异步请求通过CompletableFuture实现。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAsynGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> httpClient = HttpClient.newBuilder().build();</span><br><span class="line">    <span class="keyword">var</span> request =</span><br><span class="line">        HttpRequest.newBuilder().timeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">        .header(<span class="string">"key1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">        .header(<span class="string">"key2"</span>, <span class="string">"v2"</span>)</span><br><span class="line">        .uri(uri).build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//CompletableFuture&lt;String&gt; result = httpClient.sendAsync(request,HttpResponse.BodyHandlers.ofString()).thenApply(HttpResponse::body);</span></span><br><span class="line">        <span class="keyword">var</span> result = httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString()).thenApply(HttpResponse::body);</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK11之标准HttpClient提交Http2请求"><a href="#JDK11之标准HttpClient提交Http2请求" class="headerlink" title="JDK11之标准HttpClient提交Http2请求"></a>JDK11之标准HttpClient提交Http2请求</h2><p>HTTP2协议的强制要求https，如果⽬标URI是HTTP的，则⽆法使⽤HTTP 2协议</p>
<p>如何判断⽹站是否是http2协议，浏览器，network⾯板，选择protocol</p>
<p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701150919.png" alt="image-20210701150912334"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String targetUrl = <span class="string">"https://http2.akamai.com/demo"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> URI uri = URI.create(targetUrl);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHttp2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> httpClient = HttpClient.newBuilder()</span><br><span class="line">        .connectTimeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">        .version(HttpClient.Version.HTTP_2)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">        .timeout(Duration.ofMillis(<span class="number">3000</span>))</span><br><span class="line">        .header(<span class="string">"key1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">        .header(<span class="string">"key2"</span>, <span class="string">"v2"</span>)</span><br><span class="line">        .uri(uri)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> response = httpClient.send(request,HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        System.out.println(response.body());</span><br><span class="line">        System.out.println(response.version());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDK12和JDK13"><a href="#JDK12和JDK13" class="headerlink" title="JDK12和JDK13"></a>JDK12和JDK13</h1><h2 id="JDK⼀些基础知识科普"><a href="#JDK⼀些基础知识科普" class="headerlink" title="JDK⼀些基础知识科普"></a>JDK⼀些基础知识科普</h2><p>OpenJDK和OracleJDK版本区别：OpenJDK是JDK的开放源码版本，以GPL协议的形式发布（General Public License） Oracle JDK采⽤了商业实现</p>
<p><strong>LTS 是啥意思？</strong></p>
<p>Long Term Support ⻓期⽀持的版本，如JDK8、JDK11都是属于LTS JDK9 和 JDK10 这两个被称为“功能性的版本”不同, 两者均只提供半年的技术⽀持 甲⻣⽂释出Java的政策，每6个⽉会有⼀个版本的释出，⻓期⽀持版本每三年发布⼀次，根据 后续的发布计划，下⼀个⻓期⽀持版 Java 17 将于2021年发布</p>
<p><strong>8u20、11u20是啥意思？</strong></p>
<p>就是Java的补丁，⽐如JDK8的 8u20版本、8u60版本; java11的 11u20、11u40版本</p>
<p><strong>JDK要收费了？？？？</strong></p>
<p>Oracle 宣布 Java8 在 2019 年 1⽉之后停⽌更新，另外 Java11 及以后版本将不再提供免 费的 long-term support (LTS) ⽀持，猜测未来将有越来越多 Java 开发者转向使⽤ OpenJDK</p>
<p>OpenJDK是免费的，想要不断体验新特性的developer来说是不错的选择，OracleJDK不是免费的，对于企业⽤户来说，有钱的情况下就选择OracleJDK，对应oracleJDK，我们可以⾃⼰⽤来写代码，调试，学习即可</p>
<h2 id="JDK13新特性之多⾏⽂本块"><a href="#JDK13新特性之多⾏⽂本块" class="headerlink" title="JDK13新特性之多⾏⽂本块"></a>JDK13新特性之多⾏⽂本块</h2><p>JDK13发布，主要更新点 </p>
<ul>
<li><p><a href="https://openjdk.java.net/projects/jdk/13/" target="_blank" rel="noopener">https://openjdk.java.net/projects/jdk/13/</a> </p>
</li>
<li><p><a href="https://www.oracle.com/technetwork/java/javase/13-relnote-issues-5460548.html#NewFeature" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/13-relnote-issues-5460548.html#NewFeature</a></p>
</li>
<li><p>JEP全称 ：JDK Enhancement Proposal 特性增强提议</p>
<p><img src="https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210701151750.png" alt="image-20210701151747753"></p>
</li>
</ul>
<p><strong>多⾏⽂本块</strong> </p>
<p>旧：在java代码⾥⾯编写多⾏源码带有特殊字符则需要转义，如HTML，sql等 </p>
<p>新：原⽣字符串⽂字（raw string literals），它可以跨多⾏源码⽽不对转义字符进⾏转义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//旧：</span></span><br><span class="line">String html = <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">    		 <span class="string">" 	&lt;body&gt;\n"</span> +</span><br><span class="line">    		 <span class="string">" 		&lt;p&gt;Hello, world&lt;/p&gt;\n"</span> +</span><br><span class="line">    		 <span class="string">" 	&lt;/body&gt;\n"</span> +</span><br><span class="line">    		 <span class="string">"&lt;/html&gt;\n"</span>;</span><br><span class="line">String query = <span class="string">"SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\n"</span> +</span><br><span class="line">    <span class="string">"WHERE `CITY` = 'INDIANAPOLIS'\n"</span> +</span><br><span class="line">    <span class="string">"ORDER BY `EMP_ID`, `LAST_NAME`;\n"</span>;</span><br><span class="line"><span class="comment">//新：</span></span><br><span class="line">String html = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                &lt;html&gt;</span></span><br><span class="line"><span class="string">                	&lt;body&gt;</span></span><br><span class="line"><span class="string">                		&lt;p&gt;Hello, world&lt;/p&gt;</span></span><br><span class="line"><span class="string">                	&lt;/body&gt;</span></span><br><span class="line"><span class="string">                &lt;/html&gt;</span></span><br><span class="line"><span class="string"> 			 "</span><span class="string">""</span>;</span><br><span class="line">String query = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                 SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`</span></span><br><span class="line"><span class="string">                 WHERE `CITY` = 'INDIANAPOLIS'</span></span><br><span class="line"><span class="string">                 ORDER BY `EMP_ID`, `LAST_NAME`;</span></span><br><span class="line"><span class="string">			  "</span><span class="string">""</span>;</span><br><span class="line"><span class="comment">//对⽐⼀</span></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">line 1</span></span><br><span class="line"><span class="string">line 2</span></span><br><span class="line"><span class="string">line 3</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"><span class="comment">//等效于字符串⽂字：</span></span><br><span class="line"><span class="string">"line 1\nline 2\nline 3\n"</span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">//对⽐⼆</span></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">line 1</span></span><br><span class="line"><span class="string">line 2</span></span><br><span class="line"><span class="string">line 3"</span><span class="string">""</span></span><br><span class="line"><span class="comment">//等效于字符串⽂字：</span></span><br><span class="line"><span class="string">"line 1\nline 2\nline 3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对⽐三</span></span><br><span class="line"><span class="comment">//⽂本块可以表示空字符串，但不建议这样做，因为它需要两⾏代码：</span></span><br><span class="line">String empty = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span>;</span><br><span class="line"><span class="comment">//注意：错误例⼦</span></span><br><span class="line">String a = <span class="string">""</span><span class="string">""</span><span class="string">""</span>; <span class="comment">// no line terminator after opening delimiter</span></span><br><span class="line">String b = <span class="string">""</span><span class="string">" "</span><span class="string">""</span>; <span class="comment">// no line terminator after opening delimiter</span></span><br><span class="line">String c = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string"> "</span>;</span><br></pre></td></tr></table></figure>

<p><strong>开启新版⽀持 jshell –enable-preview</strong></p>
<h2 id="JDK13新特性之增强switch表达式"><a href="#JDK13新特性之增强switch表达式" class="headerlink" title="JDK13新特性之增强switch表达式"></a>JDK13新特性之增强switch表达式</h2><p>旧：没有break，则匹配的case后⾯会⼀直输出， value类型 可以是 byte、short、int 、char、 String 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOldSwitch1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOldSwitch2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"one"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"two"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新：<strong>使⽤箭头函数，不⽤声明break，会⾃动终⽌，⽀持多个值匹配,使⽤逗号分隔</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNewSwitch</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"zero"</span>);</span><br><span class="line">            System.out.println(<span class="string">"这是多⾏语句"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>,<span class="number">11</span>,<span class="number">111</span> -&gt; System.out.println(<span class="string">"one"</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">"two"</span>);</span><br><span class="line">        <span class="keyword">default</span> -&gt; System.out.println(<span class="string">"default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后：</p>
<ol>
<li>多关注LTS版本如JDK8,JDK11,JDK17(未发布)，这个是重点需要学的；</li>
<li>功能性的则挑选常⽤的特性进⾏掌握即可； </li>
<li>预览性的可以先不学或者简单知道就⾏，例如 AOT，ZGC,CDS 这些；</li>
<li>未来的LTS版本中会更新，所以可以关注未来的LTS版本</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Kaluna</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://blog.kaluna.top/2021/06/30/JDK8-13%E6%96%B0%E7%89%B9%E6%80%A7/">https://blog.kaluna.top/2021/06/30/JDK8-13%E6%96%B0%E7%89%B9%E6%80%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JDK8-13%E6%96%B0%E7%89%B9%E6%80%A7/">JDK8~13新特性</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://i.loli.net/2021/04/20/FbPtxEHeSDgCXBy.jpg"><div class="post-qr-code__desc">添加我为好友</div></div></div><nav id="pagination"><div class="next-post pull-right"><a href="/2021/06/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><span>多线程基础和线程池</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://blog.kaluna.top/2021/06/30/JDK8-13%E6%96%B0%E7%89%B9%E6%80%A7/';
  this.page.identifier = '2021/06/30/JDK8-13新特性/';
  this.page.title = 'JDK8~13新特性';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'shortname-pzy8cndfkq' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://shortname-pzy8cndfkq.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://gitee.com/YuerryHUAHUA/figure/raw/master/img/20210521080208.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Kaluna</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="icp"><a><span></span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>